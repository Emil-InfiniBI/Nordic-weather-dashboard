<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Realistic Snow Test</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: Arial, sans-serif;
    }
    
    #snow-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .info {
      position: fixed;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 15px;
      border-radius: 8px;
      font-size: 14px;
    }
    
    .info h2 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }
  </style>
</head>
<body>
  
  <canvas id="snow-canvas"></canvas>
  
  <div class="info">
    <h2>üå®Ô∏è Realistic Snow Animation Test</h2>
    <p>Watch the snowflakes fall naturally...</p>
    <p id="status">Initializing...</p>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    const statusEl = document.getElementById('status');
    statusEl.textContent = 'Loading Three.js...';
    
    // Wait for Three.js to load
    function init() {
      if (typeof THREE === 'undefined') {
        setTimeout(init, 100);
        return;
      }
      
      statusEl.textContent = 'Creating snow system...';
      
      const canvas = document.getElementById('snow-canvas');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 5);
      
      const renderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        alpha: true,
        antialias: false 
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      
      // Snow parameters
      const count = 800;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const sizes = new Float32Array(count);
      const velocities = [];
      const swayOffsets = [];
      
      // Initialize snowflakes
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        
        // Spread across view and depth
        const x = (Math.random() - 0.5) * 30;
        const y = Math.random() * 25 - 5; // Distributed vertically
        const z = (Math.random() - 0.5) * 30;
        
        positions[i3] = x;
        positions[i3 + 1] = y;
        positions[i3 + 2] = z;
        
        // Size based on depth (closer = bigger)
        const distanceFactor = (z + 15) / 30;
        sizes[i] = (0.05 + Math.random() * 0.15) * (0.5 + distanceFactor * 0.5);
        
        // Individual physics
        velocities.push({
          fall: 0.015 + Math.random() * 0.025,
          sway: 0.3 + Math.random() * 0.5,
          swaySpeed: 0.5 + Math.random() * 1.0
        });
        
        swayOffsets.push(Math.random() * Math.PI * 2);
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      // Create soft snowflake texture
      const textureCanvas = document.createElement('canvas');
      textureCanvas.width = 32;
      textureCanvas.height = 32;
      const ctx = textureCanvas.getContext('2d');
      
      const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 32, 32);
      
      const texture = new THREE.CanvasTexture(textureCanvas);
      
      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 1,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
        map: texture,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      const snowSystem = new THREE.Points(geometry, material);
      scene.add(snowSystem);
      
      statusEl.textContent = `‚úÖ Animation running (${count} snowflakes)`;
      
      let time = 0;
      let frameCount = 0;
      
      function animate() {
        requestAnimationFrame(animate);
        time += 0.016;
        frameCount++;
        
        const positions = snowSystem.geometry.attributes.position.array;
        
        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          const vel = velocities[i];
          const swayOffset = swayOffsets[i];
          
          let x = positions[i3];
          let y = positions[i3 + 1];
          let z = positions[i3 + 2];
          
          // Fall down
          y -= vel.fall;
          
          // Gentle sway
          x += Math.sin(time * vel.swaySpeed + swayOffset) * vel.sway * 0.01;
          
          // Slight drift
          x -= 0.005;
          
          // Reset when below view - spawn well above
          if (y < -8) {
            y = 17 + Math.random() * 5; // Spawn at 17-22
            x = (Math.random() - 0.5) * 30;
            z = (Math.random() - 0.5) * 30;
            
            // Update size for new depth
            const distanceFactor = (z + 15) / 30;
            geometry.attributes.size.array[i] = (0.05 + Math.random() * 0.15) * (0.5 + distanceFactor * 0.5);
          }
          
          // Wrap horizontally
          if (x < -15) x = 15;
          if (x > 15) x = -15;
          
          positions[i3] = x;
          positions[i3 + 1] = y;
          positions[i3 + 2] = z;
        }
        
        snowSystem.geometry.attributes.position.needsUpdate = true;
        snowSystem.geometry.attributes.size.needsUpdate = true;
        
        // Subtle camera movement
        camera.position.x = Math.sin(time * 0.05) * 0.3;
        camera.lookAt(0, 0, 0);
        
        renderer.render(scene, camera);
        
        // Update status periodically
        if (frameCount % 60 === 0) {
          statusEl.textContent = `‚úÖ Running smoothly (${count} snowflakes, ${frameCount} frames)`;
        }
      }
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      animate();
    }
    
    init();
  </script>

</body>
</html>
